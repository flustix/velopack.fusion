public enum JsonNodeType
{
    Null,
    Bool,
    Array,
    Object,
    Number,
    String
}

enum JsonToken { None, CurlyOpen, CurlyClose, SquareOpen, SquareClose, Colon, Comma, String, Number, Bool, Null }

public class JsonParseException : Exception {
}

public class JsonNode
{
    JsonNodeType Type = JsonNodeType.Null;
    Dictionary<string(), JsonNode#>() ObjectValue;
    List<JsonNode#>() ArrayValue;
    string() StringValue;
    double NumberValue;
    bool BoolValue;

    /// Get the type of this node, such as string, object, array, etc.
    /// You should use this function and then call the corresponding
    /// AsObject, AsArray, AsString, etc. functions to get the actual
    /// parsed json information.
    public JsonNodeType GetType()
    {
        return Type;
    }

    /// Check if the JSON value is null.
    public bool IsNull()
    {
        return Type == JsonNodeType.Null;
    }

    /// Reinterpret a JSON value as an object. Throws exception if the value type was not an object.
    public Dictionary<string(), JsonNode#> AsObject() throws Exception
    {
        if (Type != JsonNodeType.Object)
        {
            throw Exception("Cannot call AsObject on JsonNode which is not an object.");
        }
        return ObjectValue;
    }
    /// Reinterpret a JSON value as an array. Throws exception if the value type was not an array.
    public List<JsonNode#> AsArray() throws Exception
    {
        if (Type != JsonNodeType.Array)
        {
            throw Exception("Cannot call AsArray on JsonNode which is not an array.");
        }
        return ArrayValue;
    }

    /// Reinterpret a JSON value as a number. Throws exception if the value type was not a double.
    public double AsNumber() throws Exception
    {
        if (Type != JsonNodeType.Number)
        {
            throw Exception("Cannot call AsNumber on JsonNode which is not a number.");
        }
        return NumberValue;
    }

    /// Reinterpret a JSON value as a boolean. Throws exception if the value type was not a boolean.
    public bool AsBool() throws Exception
    {
        if (Type != JsonNodeType.Bool)
        {
            throw Exception("Cannot call AsBool on JsonNode which is not a boolean.");
        }
        return BoolValue;
    }

    /// Reinterpret a JSON value as a string. Throws exception if the value type was not a string.
    public string AsString() throws Exception
    {
        if (Type != JsonNodeType.String)
        {
            throw Exception("Cannot call AsString on JsonNode which is not a string.");
        }
        return StringValue;
    }

    public static JsonNode# Parse(string text) throws Exception, JsonParseException
    {
        JsonParser# parser = new JsonParser();
        parser.Load(text);
        return parser.ParseValue();
    }

    internal void InitBool!(bool value) throws JsonParseException
    {
        if (Type != JsonNodeType.Null)
        {
            throw JsonParseException("Cannot call InitBool on JsonNode which is not null.");
        }
        Type = JsonNodeType.Bool;
        BoolValue = value;
    }

    internal void InitArray!() throws JsonParseException
    {
        if (Type != JsonNodeType.Null)
        {
            throw JsonParseException("Cannot call InitArray on JsonNode which is not null.");
        }
        Type = JsonNodeType.Array;
    }

    internal void AddArrayChild!(JsonNode# child) throws JsonParseException
    {
        if (Type != JsonNodeType.Array)
        {
            throw JsonParseException("Cannot call AddArrayChild on JsonNode which is not an array.");
        }
        ArrayValue.Add(child);
    }

    internal void InitObject!() throws JsonParseException
    {
        if (Type != JsonNodeType.Null)
        {
            throw JsonParseException("Cannot call InitObject on JsonNode which is not null.");
        }
        Type = JsonNodeType.Object;
    }

    internal void AddObjectChild!(string key, JsonNode# child) throws JsonParseException
    {
        if (Type != JsonNodeType.Object)
        {
            throw JsonParseException("Cannot call AddObjectChild on JsonNode which is not an object.");
        }
        ObjectValue[key] = child;
    }

    internal void InitNumber!(double value) throws JsonParseException
    {
        if (Type != JsonNodeType.Null)
        {
            throw JsonParseException("Cannot call InitNumber on JsonNode which is not null.");
        }
        Type = JsonNodeType.Number;
        NumberValue = value;
    }

    internal void InitString!(string value) throws JsonParseException
    {
        if (Type != JsonNodeType.Null)
        {
            throw JsonParseException("Cannot call InitString on JsonNode which is not null.");
        }
        Type = JsonNodeType.String;
        StringValue = value;
    }
}

// https://github.com/gering/Tiny-JSON/blob/master/Tiny-JSON/Tiny-JSON/JsonParser.cs
class JsonParser
{
    string() text = "";
    int position = 0;
    StringWriter() builder;
    TextWriter! writer;

    public void Load!(string text)
    {
        this.text = text;
        this.position = 0;
        this.builder.Clear();
        this.writer = builder;
    }

    public bool EndReached()
    {
        return position >= text.Length;
    }

    public int Read!()
    {
        if (position >= text.Length)
        {
            return -1;
        }
        int c = text[position];
        position++;
        return c;
    }

    public int Peek()
    {
        if (position >= text.Length)
        {
            return -1;
        }
        return text[position];
    }

    public bool PeekWhitespace()
    {
        int c = Peek();
        return c == ' ' || c == '\t' || c == '\n' || c == '\r';
    }

    public bool PeekWordbreak()
    {
        int c = Peek();
        return c == ' ' || c == ',' || c == ':' || c == '\"' || c == '{' || c == '}' 
            || c == '[' || c == ']' || c == '\t' || c == '\n' || c == '\r';
    }

    JsonToken PeekToken!() {
        EatWhitespace();
        if (EndReached()) return JsonToken.None;
        switch (Peek()) {
            case '{':
                return JsonToken.CurlyOpen;
            case '}':
                return JsonToken.CurlyClose;
            case '[':
                return JsonToken.SquareOpen;
            case ']':
                return JsonToken.SquareClose;
            case ',':
                return JsonToken.Comma;
            case '"':
                return JsonToken.String;
            case ':':
                return JsonToken.Colon;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case '-':
                return JsonToken.Number;
            case 't':
            case 'f':
                return JsonToken.Bool;
            case 'n':
                return JsonToken.Null;
            default:
                return JsonToken.None;
        }
    }

    public void EatWhitespace!()
    {
        while (!EndReached() && PeekWhitespace())
        {
            Read();
        }
    }

    public string() ReadWord!()
    {
        builder.Clear();
        while (!EndReached() && !PeekWordbreak())
        {
            writer.WriteChar(Read());
        }
        if (EndReached()) {
            return "";
        }
        return builder.ToString();
    }

    public JsonNode# ParseNull!() throws JsonParseException 
    {
        if (PeekToken() != JsonToken.Null) {
            throw JsonParseException("Expected null");
        }
        ReadWord();
        JsonNode# node = new JsonNode();
        return node;
    }

    public JsonNode# ParseBool!() throws JsonParseException 
    {
        if (PeekToken() != JsonToken.Bool) {
            throw JsonParseException("Expected null");
        }
        string() boolValue = ReadWord();
        if (boolValue == "true") {
            JsonNode# node = new JsonNode();
            node.InitBool(true);
            return node;
        } else if (boolValue == "false") {
            JsonNode# node = new JsonNode();
            node.InitBool(false);
            return node;
        } else {
            throw JsonParseException("Invalid boolean");
        }
    }

    public JsonNode# ParseNumber!() throws JsonParseException 
    {
        if (PeekToken() != JsonToken.Number) {
            throw JsonParseException("Expected number");
        }
        double d;
        if (d.TryParse(ReadWord())) {
            JsonNode# node = new JsonNode();
            node.InitNumber(d);
            return node;
        }

        throw JsonParseException("Invalid number");
    }

    public JsonNode# ParseString!() throws JsonParseException
    {
        if (PeekToken() != JsonToken.String) {
            throw JsonParseException("Expected string");
        }

        builder.Clear();
        Read(); // ditch opening quote
      

        while (true) {
            if (EndReached()) {
                throw JsonParseException("Unterminated string");
            }
            int c = Read();
            switch (c) {
                case '"':
                    JsonNode# node = new JsonNode();
                    node.InitString(builder.ToString());
                    return node;
                case '\\':
                    if (EndReached()) {
                        throw JsonParseException("Unterminated string");
                    }
                    
                    c = Read();
                    switch (c) {
                        case '"':
                        case '\\':
                        case '/':
                            writer.WriteChar(c);
                            break;
                        case 'b':
                            writer.WriteChar(0x0008); // backspace
                            break;
                        case 'f':
                            writer.WriteChar(0x000C); // form feed
                            break;
                        case 'n':
                            writer.WriteChar('\n');
                            break;
                        case 'r':
                            writer.WriteChar('\r');
                            break;
                        case 't':
                            writer.WriteChar('\t');
                            break;
                        case 'u':
                            string() hex = $"{Read()}{Read()}{Read()}{Read()}";
                            int i;
                            if (i.TryParse(hex, 16)) {
                                writer.WriteChar(i);
                            } else {
                                throw JsonParseException("Invalid unicode escape");
                            }
                            break;
                    }
                    break;
                default:
                    writer.WriteChar(c);
                    break;
            }
        }
    }

    public JsonNode# ParseObject!() throws Exception, JsonParseException
    {
        if (PeekToken() != JsonToken.CurlyOpen) {
            throw JsonParseException("Expected object");
        }
        Read(); // ditch opening brace

        JsonNode# node = new JsonNode();
        node.InitObject();

        while (true) {
            switch (PeekToken()) {
            case JsonToken.None:
                throw JsonParseException("Unterminated object");
            case JsonToken.Comma:
                Read(); // ditch comma
                continue;
            case JsonToken.CurlyClose:
                Read(); // ditch closing brace
                return node;
            default:
                JsonNode# name = ParseString();

                if (PeekToken() != JsonToken.Colon) throw JsonParseException("Expected colon");
                Read(); // ditch the colon

                node.AddObjectChild(name.AsString(), ParseValue());
                break;
            }
        }
    }

    public JsonNode# ParseValue!() throws Exception, JsonParseException
    {
        switch (PeekToken()) {
        case JsonToken.String:		
            return ParseString();
        case JsonToken.Number:		
            return ParseNumber();
        case JsonToken.Bool:		
            return ParseBool();
        case JsonToken.Null:		
            return ParseNull();
        case JsonToken.CurlyOpen:	
            return ParseObject();
        case JsonToken.SquareOpen:	
            return ParseArray();
        default:
            throw JsonParseException("Invalid token");
        }
    }

	public JsonNode# ParseArray!() throws Exception, JsonParseException
    {
        if (PeekToken() != JsonToken.SquareOpen) {
            throw JsonParseException("Expected array");
        }
        Read(); // ditch opening brace

        JsonNode# node = new JsonNode();
        node.InitArray();

        while (true) {
            switch (PeekToken()) {
            case JsonToken.None:
                throw JsonParseException("Unterminated array");		
            case JsonToken.Comma:			
                Read(); // ditch comma
                continue;						
            case JsonToken.SquareClose:	
                Read(); // ditch closing brace
                return node;
            default:
                node.AddArrayChild(ParseValue());
                break;
            }
        }
    }
}