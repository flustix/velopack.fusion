public abstract class ProgressHandler 
{
    public abstract void OnProgress(int progress);
    public abstract void OnComplete(string() assetPath);
    public abstract void OnError(string() error);
}

public class UpdateOptions
{
    bool _allowDowngrade = false;
    string() _explicitChannel = "";
    string() _urlOrPath = "";
    ProgressHandler? _progress;
    public void SetUrlOrPath!(string() urlOrPath) { _urlOrPath = urlOrPath; }
    public string() GetUrlOrPath() { return _urlOrPath; }
    public void SetAllowDowngrade!(bool allowDowngrade) { _allowDowngrade = allowDowngrade; }
    public bool GetAllowDowngrade() { return _allowDowngrade; }
    public void SetExplicitChannel!(string() explicitChannel) { _explicitChannel = explicitChannel; }
    public string() GetExplicitChannel() { return _explicitChannel; }
    public void SetProgressHandler!(ProgressHandler? progress) { _progress = progress; }
    public ProgressHandler? GetProgressHandler() { return _progress; }
}

public class UpdateManager : Platform
{
    UpdateOptions? _options;
    public void SetOptions!(UpdateOptions? options) { _options = options; }
 
    /// This function will return the current installed version of the application
    /// or throw, if the application is not installed.
    public string() GetCurrentVersion() throws Exception
    {
        List<string()>() command;
        command.Add(Util.GetUpdateExePath());
        command.Add("get-version");
        return StartProcessBlocking(command);
    }

    /// This function will check for updates, and return information about the latest available release.
    public UpdateInfo#? CheckForUpdates() throws Exception
    {
        if (_options == null)
        {
            throw Exception("Please call SetOptions before trying to check for updates.");
        }

        List<string()>() command;
        command.Add(Util.GetUpdateExePath());
        command.Add("check");
        command.Add("--url");
        command.Add(_options.GetUrlOrPath());
        command.Add("--format");
        command.Add("json");

        if (_options.GetAllowDowngrade())
        {
            command.Add("--downgrade");
        }

        string() explicitChannel = _options.GetExplicitChannel();
        if (explicitChannel.Length > 0)
        {
            command.Add("--channel");
            command.Add(explicitChannel);
        }
    
        string() output = StartProcessBlocking(command);

        if (output.Length == 0 || output == "null")
        {
            return null;
        }

        return UpdateInfo.FromJson(output);
    }

    /// This function will request the update download, and then return immediately.
    /// To be informed of progress/completion events, please see UpdateOptions.SetProgressHandler.
    public void DownloadUpdateAsync!(UpdateInfo# updateInfo) throws Exception
    {
        if (_options == null)
        {
            throw Exception("Please call SetOptions before trying to download updates.");
        }

        List<string()>() command;
        command.Add(Util.GetUpdateExePath());
        command.Add("download");
        command.Add("--url");
        command.Add(_options.GetUrlOrPath());
        command.Add("--clean");
        command.Add("--format");
        command.Add("json");
        command.Add("--name");
        command.Add(updateInfo.TargetFullRelease.FileName);
        StartProcessAsyncReadLine(command);
    }

    public void ApplyUpdatesAndExit(string() assetPath) throws Exception 
    {
        List<string()>() args;
        WaitExitThenApplyUpdates(assetPath, false, false, args);
        Util.Exit(0);
    }

    public void ApplyUpdatesAndRestart(string() assetPath, List<string()> restartArgs) throws Exception 
    {
        WaitExitThenApplyUpdates(assetPath, false, true, restartArgs);
        Util.Exit(0);
    }

    public void WaitExitThenApplyUpdates(string() assetPath, bool silent, bool restart, List<string()> restartArgs) throws Exception 
    {
        List<string()>() command;
        command.Add(Util.GetUpdateExePath());
        if (silent) {
            command.Add("--silent");
        }
        command.Add("apply");
        command.Add("--wait");

        if (assetPath.Length > 0) {
            command.Add("--package");
            command.Add(assetPath);
        }

        if (restart) {
            command.Add("--restart");
        }

        if (restart && restartArgs.Count > 0) {
            command.Add("--");
            command.AddRange(restartArgs);
        }

        StartProcessFireAndForget(command);
    }

    protected override bool HandleProcessOutputLine!(string() line)
    {
        ProgressEvent#? ev = ProgressEvent.FromJson(line);
        if (ev == null)
        {
            // error parsing?
            return true;
        }

        if (_options.GetProgressHandler() == null) 
        {
            // can stop parsing output if no progress handler is set
            return true;
        }

        if (ev.Complete) {
            _options.GetProgressHandler().OnComplete(ev.File);
            return true;
        } else if (ev.Error.Length > 0) {
            _options.GetProgressHandler().OnError(ev.Error);
            return true;
        } else {
            _options.GetProgressHandler().OnProgress(ev.Progress);
            return false;
        }
    }
}