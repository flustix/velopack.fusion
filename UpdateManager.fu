public abstract class ProgressHandler : ProcessReadLineHandler
{
    public abstract void OnProgress!(int progress);
    public abstract void OnComplete!(string() assetPath);
    public abstract void OnError!(string() error);

    public override bool HandleProcessOutputLine!(string() line) throws Exception, JsonParseException
    {
        ProgressEvent# ev = ProgressEvent.FromJson(line);

        if (ev.Complete) {
            OnComplete(ev.File);
            return true;
        } else if (ev.Error.Length > 0) {
            OnError(ev.Error);
            return true;
        } else {
            OnProgress(ev.Progress);
            return false;
        }
    }
}

class DefaultProgressHandler : ProgressHandler
{
    public override void OnProgress!(int progress) {
    }

    public override void OnComplete!(string() assetPath) {
    }

    public override void OnError!(string() error) {
    }
}

public class UpdateManager
{
    bool _allowDowngrade = false;
    string() _explicitChannel = "";
    string() _urlOrPath = "";
    ProgressHandler# _progress = new DefaultProgressHandler();

    public void SetUrlOrPath!(string() urlOrPath) { _urlOrPath = urlOrPath; }
    public void SetAllowDowngrade!(bool allowDowngrade) { _allowDowngrade = allowDowngrade; }
    public void SetExplicitChannel!(string() explicitChannel) { _explicitChannel = explicitChannel; }
    public void SetProgressHandler!(ProgressHandler# progress) { _progress = progress; }

    /// This function will return the current installed version of the application
    /// or throw, if the application is not installed.
    public string() GetCurrentVersion() throws Exception
    {
        List<string()>() command;
        command.Add(Util.GetUpdateExePath());
        command.Add("get-version");
        return Process.StartProcessBlocking(command);
    }

    /// This function will check for updates, and return information about the latest available release.
    public UpdateInfo#? CheckForUpdates() throws Exception
    {
        if (_urlOrPath.Length == 0)
        {
            throw Exception("Please call SetUrlOrPath before trying to check for updates.");
        }

        List<string()>() command;
        command.Add(Util.GetUpdateExePath());
        command.Add("check");
        command.Add("--url");
        command.Add(_urlOrPath);
        command.Add("--format");
        command.Add("json");

        if (_allowDowngrade)
        {
            command.Add("--downgrade");
        }

        if (_explicitChannel.Length > 0)
        {
            command.Add("--channel");
            command.Add(_explicitChannel);
        }
    
        string() output = Process.StartProcessBlocking(command);

        if (output.Length == 0 || output == "null")
        {
            return null;
        }

        return UpdateInfo.FromJson(output);
    }

    /// This function will request the update download, and then return immediately.
    /// To be informed of progress/completion events, please see UpdateOptions.SetProgressHandler.
    public void DownloadUpdateAsync!(UpdateInfo# updateInfo) throws Exception
    {
        if (_urlOrPath.Length == 0)
        {
            throw Exception("Please call SetUrlOrPath before trying to download updates.");
        }

        List<string()>() command;
        command.Add(Util.GetUpdateExePath());
        command.Add("download");
        command.Add("--url");
        command.Add(_urlOrPath);
        command.Add("--clean");
        command.Add("--format");
        command.Add("json");
        command.Add("--name");
        command.Add(updateInfo.TargetFullRelease.FileName);
        Process.StartProcessAsyncReadLine(command, _progress);
    }

    public void ApplyUpdatesAndExit(string() assetPath) throws Exception 
    {
        List<string()>() args;
        WaitExitThenApplyUpdates(assetPath, false, false, args);
        Util.Exit(0);
    }

    public void ApplyUpdatesAndRestart(string() assetPath, List<string()>? restartArgs = null) throws Exception 
    {
        WaitExitThenApplyUpdates(assetPath, false, true, restartArgs);
        Util.Exit(0);
    }

    public void WaitExitThenApplyUpdates(string() assetPath, bool silent, bool restart, List<string()>? restartArgs = null) throws Exception 
    {
        List<string()>() command;
        command.Add(Util.GetUpdateExePath());
        if (silent) {
            command.Add("--silent");
        }
        command.Add("apply");
        command.Add("--wait");

        if (assetPath.Length > 0) {
            command.Add("--package");
            command.Add(assetPath);
        }

        if (restart) {
            command.Add("--restart");
        }

        if (restart && restartArgs != null && restartArgs.Count > 0) {
            command.Add("--");
            command.AddRange(restartArgs);
        }

        Process.StartProcessFireAndForget(command);
    }

   
}