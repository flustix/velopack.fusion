
#if CPP
native {
    #include <functional>
    #include <iostream>
    #include <fstream>
    #include <sstream>
    #include <thread>
}
#endif

#if JS
native {
    const { spawn, spawnSync } = require("child_process");
    function emitLines (stream) {
        var backlog = "";
        stream.on("data", function (data) {
            backlog += data
            var n = backlog.indexOf('\n')
            // got a \n? emit one or more 'line' events
            while (~n) {
                stream.emit("line", backlog.substring(0, n))
                backlog = backlog.substring(n + 1)
                n = backlog.indexOf('\n')
            }
        })
        stream.on("end", function () {
            if (backlog) {
                stream.emit("line", backlog)
            }
        })
    }
}
#endif

public abstract class ProcessReadLineHandler
{
    /// Called when a line of output is read from the process.
    /// If this method returns true, the reading loop is terminated.
    public abstract bool HandleProcessOutputLine!(string() line);
}

static class Process
{
    /// Starts a new process and sychronously reads/returns its output.
    public static string() StartProcessBlocking(List<string()> command_line) throws Exception
    {
        if (command_line.Count == 0) {
            throw Exception("Command line is empty");
        }

        string() ret = "";
#if CPP
        native { 
	        subprocess_s subprocess = util_start_subprocess(command_line, subprocess_option_no_window);

            // read all stdout from the process
            FILE* p_stdout = subprocess_stdout(&subprocess);
            std::filebuf buf = std::basic_filebuf<char>(p_stdout);
            std::istream is(&buf);
            std::stringstream buffer;
            buffer << is.rdbuf();
            ret = buffer.str();
         }
#elif CS
        native {
            var psi = new System.Diagnostics.ProcessStartInfo()
            {
                CreateNoWindow = true,
                FileName = command_line[0],
                RedirectStandardError = true, 
                RedirectStandardInput = true, 
                UseShellExecute = false,
            };

            foreach (var arg in command_line.Skip(1))
            {
                psi.ArgumentList.Add(arg);
            }

            System.Text.StringBuilder output = new System.Text.StringBuilder();

            var process = new System.Diagnostics.Process();
            process.StartInfo = psi;
            process.ErrorDataReceived += (sender, e) => {
                if (e.Data != null) output.AppendLine(e.Data);
            };
            process.OutputDataReceived += (sender, e) => {
                if (e.Data != null) output.AppendLine(e.Data);
            };

            process.Start();
            process.BeginErrorReadLine();
            process.BeginOutputReadLine();
            process.WaitForExit();
            ret = output.ToString();
        }
#elif JS || TS
        native { ret = spawnSync(command_line[0], command_line.slice(1), { encoding: "utf8" }).stdout; } 
#else
        throw Exception("Unsupported platform");
#endif

        return Util.StrTrim(ret);
    }

    /// Starts a new process and returns immediately.
    public static void StartProcessFireAndForget(List<string()> command_line) throws Exception
    {
        if (command_line.Count == 0) {
            throw Exception("Command line is empty");
        }
#if CPP
        native { util_start_subprocess(command_line, subprocess_option_no_window); }
#elif CS
        native {
            var psi = new System.Diagnostics.ProcessStartInfo()
            {
                CreateNoWindow = true,
                FileName = command_line[0],
            };
            foreach (var arg in command_line.Skip(1)) psi.ArgumentList.Add(arg);
            System.Diagnostics.Process.Start(psi);
        }
#elif JS || TS
        native { spawn(command_line[0], command_line.slice(1), { encoding: "utf8" }); } 
#else
        throw Exception("Unsupported platform");
#endif
    }

    /// In the current process, starts a new process and asychronously reads its output line by line.
    /// When a line is read, HandleProcessOutputLine is called with the line. 
    /// If HandleProcessOutputLine returns true, the reading loop is terminated.
    /// This method is non-blocking and returns immediately.
    public static void StartProcessAsyncReadLine(List<string()> command_line, ProcessReadLineHandler! handler) throws Exception
    {
        if (command_line.Count == 0) {
            throw Exception("Command line is empty");
        }
#if CPP
        native { 
	        subprocess_s subprocess = util_start_subprocess(command_line, subprocess_option_no_window | subprocess_option_enable_async);

            std::thread outputThread([subprocess, handler]() mutable {
                const unsigned BUFFER_SIZE = 1024;
                char readBuffer[BUFFER_SIZE];
                std::string accumulatedData;

                // read all stdout from the process one line at a time
                while (true) {
                    unsigned bytesRead = subprocess_read_stdout(&subprocess, readBuffer, BUFFER_SIZE - 1);

                    if (bytesRead == 0) {
                        // bytesRead is 0, indicating the process has completed
                        // Process any remaining data in accumulatedData as the last line if needed
                        if (!accumulatedData.empty()) {
                            handler->handleProcessOutputLine(accumulatedData);
                        }
                        return;
                    }

                    accumulatedData += std::string(readBuffer, bytesRead);

                    // Process accumulated data for lines
                    size_t pos;
                    while ((pos = accumulatedData.find('\n')) != std::string::npos) {
                        std::string line = accumulatedData.substr(0, pos);
                        if (handler->handleProcessOutputLine(line)) {
                            return; // complete or err
                        }
                        accumulatedData.erase(0, pos + 1);
                    }
                }
            });
        }
#elif CS
        native {
            var psi = new System.Diagnostics.ProcessStartInfo()
            {
                CreateNoWindow = true,
                FileName = command_line[0],
                RedirectStandardError = true, 
                RedirectStandardInput = true, 
                UseShellExecute = false,
            };

            foreach (var arg in command_line.Skip(1))
            {
                psi.ArgumentList.Add(arg);
            }

            var process = new System.Diagnostics.Process();
            process.StartInfo = psi;
            process.ErrorDataReceived += (sender, e) => {
                if (e.Data != null) handler.HandleProcessOutputLine(e.Data);
            };
            process.OutputDataReceived += (sender, e) => {
                if (e.Data != null) handler.HandleProcessOutputLine(e.Data);
            };

            process.Start();
            process.BeginErrorReadLine();
            process.BeginOutputReadLine();
        }
#elif JS || TS
        native {
            const child = spawn(command_line[0], command_line.slice(1), { encoding: "utf8" });
            emitLines(child.stdout);
            child.stdout.resume()
            child.stdout.setEncoding("utf8")
            child.stdout.on("line", (data) => {
                handler.handleProcessOutputLine(data)
            });
        } 
#else
        throw Exception("Unsupported platform");
#endif
    }
}