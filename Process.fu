
#if JS
native {
    const { spawn, spawnSync } = require("child_process");
    function emitLines (stream) {
        var backlog = "";
        stream.on("data", function (data) {
            backlog += data
            var n = backlog.indexOf('\n')
            // got a \n? emit one or more 'line' events
            while (~n) {
                stream.emit("line", backlog.substring(0, n))
                backlog = backlog.substring(n + 1)
                n = backlog.indexOf('\n')
            }
        })
        stream.on("end", function () {
            if (backlog) {
                stream.emit("line", backlog)
            }
        })
    }
}
#endif

public abstract class ProcessProgressHandler
{
}

public abstract class ProcessCompleteHandler
{
}

static class Process
{
    /// Starts a new process and sychronously reads/returns its output.
    public static string() StartProcessBlocking(List<string()> command_line) throws Exception
    {
        if (command_line.Count == 0) {
            throw Exception("Command line is empty");
        }

        string() ret = "";
#if CPP
        native { ret = util_start_process_blocking_output(command_line, subprocess_option_no_window); }
#elif CS
        native { ret = ProcessNative.StartProcessBlocking(command_line); }
#elif JS
        native { ret = spawnSync(command_line[0], command_line.slice(1), { encoding: "utf8" }).stdout; } 
#else
        throw Exception("Unsupported platform");
#endif

        return Util.StrTrim(ret);
    }

    /// Starts a new process and returns immediately.
    public static void StartProcessFireAndForget(List<string()> command_line) throws Exception
    {
        if (command_line.Count == 0) {
            throw Exception("Command line is empty");
        }
#if CPP
        native { util_start_process(command_line, subprocess_option_no_window); }
#elif CS
        native { ProcessNative.StartProcessFireAndForget(command_line); }
#elif JS || TS
        native { spawn(command_line[0], command_line.slice(1), { encoding: "utf8" }); } 
#else
        throw Exception("Unsupported platform");
#endif
    }

    /// In the current process, starts a new process and asychronously reads its output line by line.
    /// When a line is read, HandleProcessOutputLine is called with the line. 
    /// If HandleProcessOutputLine returns true, the reading loop is terminated.
    /// This method is non-blocking and returns immediately.
    public static void StartProcessAsyncReadLine(List<string()> command_line, ProcessProgressHandler progress, ProcessCompleteHandler complete) throws Exception
    {
        if (command_line.Count == 0) {
            throw Exception("Command line is empty");
        }

// #if CPP
//         native {
// 	        subprocess_s subprocess = util_start_subprocess(command_line, subprocess_option_no_window | subprocess_option_enable_async);

//             std::thread outputThread([subprocess, handler]() mutable {
//                 const unsigned BUFFER_SIZE = 1024;
//                 char readBuffer[BUFFER_SIZE];
//                 std::string accumulatedData;

//                 // read all stdout from the process one line at a time
//                 while (true) {
//                     unsigned bytesRead = subprocess_read_stdout(&subprocess, readBuffer, BUFFER_SIZE - 1);

//                     if (bytesRead == 0) {
//                         // bytesRead is 0, indicating the process has completed
//                         // Process any remaining data in accumulatedData as the last line if needed
//                         if (!accumulatedData.empty()) {
//                             handler->handleProcessOutputLine(accumulatedData);
//                         }
//                         return;
//                     }

//                     accumulatedData += std::string(readBuffer, bytesRead);

//                     // Process accumulated data for lines
//                     size_t pos;
//                     while ((pos = accumulatedData.find('\n')) != std::string::npos) {
//                         std::string line = accumulatedData.substr(0, pos);
//                         if (handler->handleProcessOutputLine(line)) {
//                             return; // complete or err
//                         }
//                         accumulatedData.erase(0, pos + 1);
//                     }
//                 }
//             });
//         }
// #elif CS
//         native {
//             var psi = new System.Diagnostics.ProcessStartInfo()
//             {
//                 CreateNoWindow = true,
//                 FileName = command_line[0],
//                 RedirectStandardError = true, 
//                 RedirectStandardInput = true, 
//                 UseShellExecute = false,
//             };

//             foreach (var arg in command_line.Skip(1))
//             {
//                 psi.ArgumentList.Add(arg);
//             }

//             var process = new System.Diagnostics.Process();
//             process.StartInfo = psi;
//             process.ErrorDataReceived += (sender, e) => {
//                 if (e.Data != null) handler.HandleProcessOutputLine(e.Data);
//             };
//             process.OutputDataReceived += (sender, e) => {
//                 if (e.Data != null) handler.HandleProcessOutputLine(e.Data);
//             };

//             process.Start();
//             process.BeginErrorReadLine();
//             process.BeginOutputReadLine();
//         }
// #elif JS || TS
//         native {
//             const child = spawn(command_line[0], command_line.slice(1), { encoding: "utf8" });
//             emitLines(child.stdout);
//             child.stdout.resume()
//             child.stdout.setEncoding("utf8")
//             child.stdout.on("line", (data) => {
//                 handler.handleProcessOutputLine(data)
//             });
//         } 
// #else
//         throw Exception("Unsupported platform");
// #endif
    }
}